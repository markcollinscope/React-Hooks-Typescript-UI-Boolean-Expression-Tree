{"ast":null,"code":"// Abstraction of the concept of a boolean expression.\n// Deals with creation and calcution of such expressions, including constants values (T, F and U), \n// binary operations, unary operations (well NOT_OP only at the moment), and boolean logic extended to \n// undefined values.\n\n/*\n\tHere's the grammar the Exp inheritance tree conforms to (or enables) below... (BNF format-ish):\n\n\tExp ::= Exp | ConstExp | BinExp | NotExp\n\t// UniExp - no other unary operators except Not, so no point...\n\t\n\tNotExp ::= 'Not' Exp \n\n\tBinExp ::= binOp Exp Exp\n\tbinOp ::= 'And' | 'Or' | 'Xor' | 'Nand' | 'Nor'\n\n\tConstExp ::= trueExp | falseExp | undefExp\n\n\t// implented as immutable constants in code.\n\tundefExp ::= 'Undefined'\n\ttrueExp ::= 'True'\n\tfalseExp ::= 'False'\n\n\tKey:-\n\t'inQuotes' means the string in question can be found in the code.\n\tlowerCase first letter on a name means there is not a class for this in the impl - it's just for grammar expansion.\n\tUpperCase means there's a class for it in the impl.\n\n\tnb: no UI related stuff here.\n*/\n\nimport { uNot, uAnd, uOr, uBoolToName } from './ubool';\n\n// backwards compatibility after file restructure.\nexport { uNot, uAnd, uOr, TRUE, FALSE, UNDEF, uBoolToName } from './ubool';\n\n//******\nexport class Exp {\n  constructor(op) {\n    this.op = op;\n    this.name = () => this.op;\n  }\n\n  // calculate the value of the Exp.\n}\n\n//******\nclass ConstExp extends Exp // nb: not exported. Only pre-defined constants are exported.\n{\n  constructor(value) {\n    super(uBoolToName(value));\n    this.value = value;\n    this.calc = () => this.value;\n    this.expand = () => this.name();\n  }\n}\n\n/* standard constant expression values - exported */\nexport const UNDEF_EXP = new ConstExp(undefined);\nexport const TRUE_EXP = new ConstExp(true);\nexport const FALSE_EXP = new ConstExp(false);\nexport const DEFAULT_EXP = UNDEF_EXP; // default parameter/argument value - not absolutely necessary.\n\nexport const LB = ' ( ';\nexport const RB = ' ) ';\nexport const SEPERATOR = ' , ';\nexport class UniExp extends Exp {\n  constructor(operatorValue, subExp) {\n    super(operatorValue);\n    this.operatorValue = operatorValue;\n    this.subExp = subExp;\n    this.expand = () => this.name() + LB + this.getSubExp().expand() + RB;\n    this.getSubExp = () => this.subExp;\n    this.setSubExp = e => this.subExp = e;\n    this.setSubExp(subExp);\n  }\n\n  /*  Std Exp Ops */\n}\n\nexport class BinExp extends Exp {\n  constructor(operator, lhs, rhs) {\n    super(operator);\n    this.lhs = lhs;\n    this.rhs = rhs;\n    this.expand = () => this.name() + LB + this.getLhsExp().expand() + SEPERATOR + this.getRhsExp().expand() + RB;\n    this.setLhsExp = e => this.lhs = e;\n    this.setRhsExp = e => this.rhs = e;\n    this.getLhsExp = () => this.lhs;\n    this.getRhsExp = () => this.rhs;\n  }\n\n  /* Std Exp Ops - nb: No calc() as don't know how to calc() in abstract BinExp type  */\n}\n\nexport const NOT_OP = 'Not';\nexport class NotExp extends UniExp {\n  constructor() {\n    let subExp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_EXP;\n    super(NOT_OP, subExp);\n    this.calc = () => uNot(this.getSubExp().calc());\n  }\n}\nexport const AND_OP = 'And';\nexport class AndExp extends BinExp {\n  constructor() {\n    let lhs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_EXP;\n    let rhs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_EXP;\n    super(AND_OP, lhs, rhs);\n    this.calc = () => uAnd(this.getLhsExp().calc(), this.getRhsExp().calc());\n  }\n}\nexport const OR_OP = 'Or';\nexport class OrExp extends BinExp {\n  constructor() {\n    let lhs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_EXP;\n    let rhs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_EXP;\n    super(OR_OP, lhs, rhs);\n    this.calc = () => uOr(this.getLhsExp().calc(), this.getRhsExp().calc());\n  }\n}\nexport const NAND_OP = 'Nand';\nexport class NandExp extends BinExp {\n  constructor() {\n    let lhs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_EXP;\n    let rhs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_EXP;\n    super(NAND_OP, lhs, rhs);\n    this.calc = () => uNot(uAnd(this.getLhsExp().calc(), this.getRhsExp().calc()));\n  }\n}\nexport const NOR_OP = 'Nor';\nexport class NorExp extends BinExp {\n  constructor() {\n    let lhs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_EXP;\n    let rhs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_EXP;\n    super(NOR_OP, lhs, rhs);\n    this.calc = () => uNot(uOr(this.getLhsExp().calc(), this.getRhsExp().calc()));\n  }\n}\nexport const XOR_OP = 'Xor';\nexport class XorExp extends BinExp {\n  constructor() {\n    let lhs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_EXP;\n    let rhs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_EXP;\n    super(XOR_OP, lhs, rhs);\n    this.calc = () => uOr(uAnd(this.getLhsExp().calc(), uNot(this.getRhsExp().calc())), uAnd(uNot(this.getLhsExp().calc()), this.getRhsExp().calc()));\n  }\n}","map":{"version":3,"names":["uNot","uAnd","uOr","uBoolToName","TRUE","FALSE","UNDEF","Exp","constructor","op","name","ConstExp","value","calc","expand","UNDEF_EXP","undefined","TRUE_EXP","FALSE_EXP","DEFAULT_EXP","LB","RB","SEPERATOR","UniExp","operatorValue","subExp","getSubExp","setSubExp","e","BinExp","operator","lhs","rhs","getLhsExp","getRhsExp","setLhsExp","setRhsExp","NOT_OP","NotExp","AND_OP","AndExp","OR_OP","OrExp","NAND_OP","NandExp","NOR_OP","NorExp","XOR_OP","XorExp"],"sources":["/home/mark/GIT/exp-tree/src/Exp.ts"],"sourcesContent":["// Abstraction of the concept of a boolean expression.\n// Deals with creation and calcution of such expressions, including constants values (T, F and U), \n// binary operations, unary operations (well NOT_OP only at the moment), and boolean logic extended to \n// undefined values.\n\n/*\n\tHere's the grammar the Exp inheritance tree conforms to (or enables) below... (BNF format-ish):\n\n\tExp ::= Exp | ConstExp | BinExp | NotExp\n\t// UniExp - no other unary operators except Not, so no point...\n\t\n\tNotExp ::= 'Not' Exp \n\n\tBinExp ::= binOp Exp Exp\n\tbinOp ::= 'And' | 'Or' | 'Xor' | 'Nand' | 'Nor'\n\n\tConstExp ::= trueExp | falseExp | undefExp\n\n\t// implented as immutable constants in code.\n\tundefExp ::= 'Undefined'\n\ttrueExp ::= 'True'\n\tfalseExp ::= 'False'\n\n\tKey:-\n\t'inQuotes' means the string in question can be found in the code.\n\tlowerCase first letter on a name means there is not a class for this in the impl - it's just for grammar expansion.\n\tUpperCase means there's a class for it in the impl.\n\n\tnb: no UI related stuff here.\n*/\n\nimport {  uBoolean, uNot, uAnd, uOr, uBoolToName } from './ubool';\n\n// backwards compatibility after file restructure.\nexport {  uNot, uAnd, uOr, TRUE, FALSE, UNDEF, uBoolToName } from './ubool';\n\n//******\nexport abstract class Exp\n{\n\tconstructor(private op: string) {};\t// save operator type\n\tname = () => this.op;\t\t\t\t// what is the name of the Exp's operator. Concrete impl, all Exp types.\n\tabstract expand(): \tstring;\t\t\t\t// return a string expansion of the Exp.\n\tabstract calc():\tuBoolean;\t\t\t// calculate the value of the Exp.\n}\n\n//******\nclass ConstExp extends Exp\t// nb: not exported. Only pre-defined constants are exported.\n{\n\tconstructor(private value: uBoolean) { super( uBoolToName(value) ); }\n\tcalc = () => this.value;\n\texpand = () => this.name();\n}\n\n/* standard constant expression values - exported */\nexport const UNDEF_EXP = \tnew ConstExp(undefined);\nexport const TRUE_EXP = \tnew ConstExp(true);\nexport const FALSE_EXP = \tnew ConstExp(false);\n\nexport const DEFAULT_EXP = UNDEF_EXP;\t// default parameter/argument value - not absolutely necessary.\n\nexport const LB = ' ( ';\nexport const RB = ' ) ';\nexport const SEPERATOR = ' , ';\n\nexport abstract class UniExp extends Exp\n{\n\tconstructor(private operatorValue: string, private subExp: Exp)\n\t{\n\t\tsuper(operatorValue);\n\t\tthis.setSubExp(subExp);\n\t}\n\n\t/*  Std Exp Ops */\n\texpand = () => this.name() + LB + this.getSubExp().expand() + RB;\n\t\n\t/* Unary Exp Specific Ops */\n\tgetSubExp = () => this.subExp\n\tsetSubExp = (e: Exp) => this.subExp = e;\n}\n\nexport abstract class BinExp extends Exp\n{\n\tconstructor(operator: string, private lhs: Exp, private rhs: Exp) \n\t{ \n\t\tsuper(operator); \n\t}\n\n\t/* Std Exp Ops - nb: No calc() as don't know how to calc() in abstract BinExp type  */\n\texpand = () => this.name() + LB + this.getLhsExp().expand() + SEPERATOR + this.getRhsExp().expand() + RB;\n\t\n\t/* BinExp only ops - i.e. only make sense for binary operators / expression nodes */\n\t// simple setters/getters - nb: these are implementations that all binary expressions will share.\n\t// here binary expression means any class derived from (extend-ing) BinExp\n\tsetLhsExp = (e: Exp) => this.lhs =  e;\n\tsetRhsExp = (e: Exp) => this.rhs =  e;\n\tgetLhsExp = () => this.lhs;\n\tgetRhsExp = () => this.rhs;\n}\n\nexport const NOT_OP = 'Not' as string;\nexport class NotExp extends UniExp\n{\n\tconstructor(subExp: Exp = DEFAULT_EXP) { super(NOT_OP, subExp); }\n\tcalc = (): uBoolean => uNot( this.getSubExp().calc() );\n}\n\nexport const AND_OP = 'And' as string;\nexport class AndExp extends BinExp\n{\n\tconstructor(lhs: Exp = DEFAULT_EXP, rhs: Exp = DEFAULT_EXP) { super (AND_OP, lhs, rhs); }\n\tcalc = () => uAnd( this.getLhsExp().calc(), this.getRhsExp().calc() )\n}\n\nexport const OR_OP = 'Or' as string\nexport class OrExp extends BinExp\n{\n\tconstructor(lhs: Exp = DEFAULT_EXP, rhs: Exp = DEFAULT_EXP) { super (OR_OP, lhs, rhs); }\n\tcalc = () => uOr(this.getLhsExp().calc(), this.getRhsExp().calc())\n}\n\nexport const NAND_OP = 'Nand' as string;\nexport class NandExp extends BinExp\n{\n\tconstructor(lhs: Exp = DEFAULT_EXP, rhs: Exp = DEFAULT_EXP) { super (NAND_OP, lhs, rhs); }\n\tcalc = () => uNot( uAnd(this.getLhsExp().calc(), this.getRhsExp().calc()) );\n}\n\nexport const NOR_OP = 'Nor' as string;\nexport class NorExp extends BinExp\n{\n\tconstructor(lhs: Exp = DEFAULT_EXP, rhs: Exp = DEFAULT_EXP) { super (NOR_OP, lhs, rhs); }\n\tcalc = () => uNot( uOr(this.getLhsExp().calc(), this.getRhsExp().calc()) )\n}\n\nexport const XOR_OP = 'Xor' as string;\nexport class XorExp extends BinExp \n{\n\tconstructor(lhs: Exp = DEFAULT_EXP, rhs: Exp = DEFAULT_EXP) { super (XOR_OP, lhs, rhs); }\n\tcalc = () => uOr(\n \t\tuAnd( this.getLhsExp().calc(), uNot(this.getRhsExp().calc()) ),\n\t\tuAnd( uNot(this.getLhsExp().calc()), this.getRhsExp().calc() )\n\t);\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}