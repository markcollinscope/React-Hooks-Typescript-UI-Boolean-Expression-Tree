{"ast":null,"code":"import _inherits from\"/home/mark/GIT/exp-tree/node_modules/@babel/runtime/helpers/esm/inherits.js\";import _createSuper from\"/home/mark/GIT/exp-tree/node_modules/@babel/runtime/helpers/esm/createSuper.js\";import _createClass from\"/home/mark/GIT/exp-tree/node_modules/@babel/runtime/helpers/esm/createClass.js\";import _classCallCheck from\"/home/mark/GIT/exp-tree/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";// Abstraction of the concept of a boolean expression.\n// Deals with creation and calcution of such expressions, including constants values (T, F and U), \n// binary operations, unary operations (well NOT_OP only at the moment), and boolean logic extended to \n// undefined values.\n/*\n\tHere's the grammar the Exp inheritance tree conforms to (or enables) below... (BNF format-ish):\n\n\tExp ::= Exp | ConstExp | BinExp | NotExp\n\t// UniExp - no other unary operators except Not, so no point...\n\t\n\tNotExp ::= 'Not' Exp \n\n\tBinExp ::= binOp Exp Exp\n\tbinOp ::= 'And' | 'Or' | 'Xor' | 'Nand' | 'Nor'\n\n\tConstExp ::= trueExp | falseExp | undefExp\n\n\t// implented as immutable constants in code.\n\tundefExp ::= 'Undefined'\n\ttrueExp ::= 'True'\n\tfalseExp ::= 'False'\n\n\tKey:-\n\t'inQuotes' means the string in question can be found in the code.\n\tlowerCase first letter on a name means there is not a class for this in the impl - it's just for grammar expansion.\n\tUpperCase means there's a class for it in the impl.\n\n\tnb: no UI related stuff here.\n*/import{uNot,uAnd,uOr,uBoolToName}from'./ubool';// backwards compatibility after file restructure.\nexport{uNot,uAnd,uOr,TRUE,FALSE,UNDEF,uBoolToName}from'./ubool';//******\nexport var Exp=/*#__PURE__*/_createClass(function Exp(op){var _this=this;_classCallCheck(this,Exp);this.op=op;this.name=function(){return _this.op;};});//******\nvar ConstExp=/*#__PURE__*/function(_Exp){_inherits(ConstExp,_Exp);var _super=_createSuper(ConstExp);function ConstExp(value){var _this2;_classCallCheck(this,ConstExp);_this2=_super.call(this,uBoolToName(value));_this2.value=value;_this2.calc=function(){return _this2.value;};_this2.expand=function(){return _this2.name();};return _this2;}return _createClass(ConstExp);}(Exp// nb: not exported. Only pre-defined constants are exported.\n);/* standard constant expression values - exported */export var UNDEF_EXP=new ConstExp(undefined);export var TRUE_EXP=new ConstExp(true);export var FALSE_EXP=new ConstExp(false);export var DEFAULT_EXP=UNDEF_EXP;// default parameter/argument value - not absolutely necessary.\nexport var LB=' ( ';export var RB=' ) ';export var SEPERATOR=' , ';export var UniExp=/*#__PURE__*/function(_Exp2){_inherits(UniExp,_Exp2);var _super2=_createSuper(UniExp);function UniExp(operatorValue,subExp){var _this3;_classCallCheck(this,UniExp);_this3=_super2.call(this,operatorValue);_this3.operatorValue=operatorValue;_this3.subExp=subExp;_this3.expand=function(){return _this3.name()+LB+_this3.getSubExp().expand()+RB;};_this3.getSubExp=function(){return _this3.subExp;};_this3.setSubExp=function(e){return _this3.subExp=e;};_this3.setSubExp(subExp);return _this3;}/*  Std Exp Ops */return _createClass(UniExp);}(Exp);export var BinExp=/*#__PURE__*/function(_Exp3){_inherits(BinExp,_Exp3);var _super3=_createSuper(BinExp);function BinExp(operator,lhs,rhs){var _this4;_classCallCheck(this,BinExp);_this4=_super3.call(this,operator);_this4.lhs=lhs;_this4.rhs=rhs;_this4.expand=function(){return _this4.name()+LB+_this4.getLhsExp().expand()+SEPERATOR+_this4.getRhsExp().expand()+RB;};_this4.setLhsExp=function(e){return _this4.lhs=e;};_this4.setRhsExp=function(e){return _this4.rhs=e;};_this4.getLhsExp=function(){return _this4.lhs;};_this4.getRhsExp=function(){return _this4.rhs;};return _this4;}/* Std Exp Ops - nb: No calc() as don't know how to calc() in abstract BinExp type  */return _createClass(BinExp);}(Exp);export var NOT_OP='Not';export var NotExp=/*#__PURE__*/function(_UniExp){_inherits(NotExp,_UniExp);var _super4=_createSuper(NotExp);function NotExp(){var _this5;var subExp=arguments.length>0&&arguments[0]!==undefined?arguments[0]:DEFAULT_EXP;_classCallCheck(this,NotExp);_this5=_super4.call(this,NOT_OP,subExp);_this5.calc=function(){return uNot(_this5.getSubExp().calc());};return _this5;}return _createClass(NotExp);}(UniExp);export var AND_OP='And';export var AndExp=/*#__PURE__*/function(_BinExp){_inherits(AndExp,_BinExp);var _super5=_createSuper(AndExp);function AndExp(){var _this6;var lhs=arguments.length>0&&arguments[0]!==undefined?arguments[0]:DEFAULT_EXP;var rhs=arguments.length>1&&arguments[1]!==undefined?arguments[1]:DEFAULT_EXP;_classCallCheck(this,AndExp);_this6=_super5.call(this,AND_OP,lhs,rhs);_this6.calc=function(){return uAnd(_this6.getLhsExp().calc(),_this6.getRhsExp().calc());};return _this6;}return _createClass(AndExp);}(BinExp);export var OR_OP='Or';export var OrExp=/*#__PURE__*/function(_BinExp2){_inherits(OrExp,_BinExp2);var _super6=_createSuper(OrExp);function OrExp(){var _this7;var lhs=arguments.length>0&&arguments[0]!==undefined?arguments[0]:DEFAULT_EXP;var rhs=arguments.length>1&&arguments[1]!==undefined?arguments[1]:DEFAULT_EXP;_classCallCheck(this,OrExp);_this7=_super6.call(this,OR_OP,lhs,rhs);_this7.calc=function(){return uOr(_this7.getLhsExp().calc(),_this7.getRhsExp().calc());};return _this7;}return _createClass(OrExp);}(BinExp);export var NAND_OP='Nand';export var NandExp=/*#__PURE__*/function(_BinExp3){_inherits(NandExp,_BinExp3);var _super7=_createSuper(NandExp);function NandExp(){var _this8;var lhs=arguments.length>0&&arguments[0]!==undefined?arguments[0]:DEFAULT_EXP;var rhs=arguments.length>1&&arguments[1]!==undefined?arguments[1]:DEFAULT_EXP;_classCallCheck(this,NandExp);_this8=_super7.call(this,NAND_OP,lhs,rhs);_this8.calc=function(){return uNot(uAnd(_this8.getLhsExp().calc(),_this8.getRhsExp().calc()));};return _this8;}return _createClass(NandExp);}(BinExp);export var NOR_OP='Nor';export var NorExp=/*#__PURE__*/function(_BinExp4){_inherits(NorExp,_BinExp4);var _super8=_createSuper(NorExp);function NorExp(){var _this9;var lhs=arguments.length>0&&arguments[0]!==undefined?arguments[0]:DEFAULT_EXP;var rhs=arguments.length>1&&arguments[1]!==undefined?arguments[1]:DEFAULT_EXP;_classCallCheck(this,NorExp);_this9=_super8.call(this,NOR_OP,lhs,rhs);_this9.calc=function(){return uNot(uOr(_this9.getLhsExp().calc(),_this9.getRhsExp().calc()));};return _this9;}return _createClass(NorExp);}(BinExp);export var XOR_OP='Xor';export var XorExp=/*#__PURE__*/function(_BinExp5){_inherits(XorExp,_BinExp5);var _super9=_createSuper(XorExp);function XorExp(){var _this10;var lhs=arguments.length>0&&arguments[0]!==undefined?arguments[0]:DEFAULT_EXP;var rhs=arguments.length>1&&arguments[1]!==undefined?arguments[1]:DEFAULT_EXP;_classCallCheck(this,XorExp);_this10=_super9.call(this,XOR_OP,lhs,rhs);_this10.calc=function(){return uOr(uAnd(_this10.getLhsExp().calc(),uNot(_this10.getRhsExp().calc())),uAnd(uNot(_this10.getLhsExp().calc()),_this10.getRhsExp().calc()));};return _this10;}return _createClass(XorExp);}(BinExp);","map":{"version":3,"names":["uNot","uAnd","uOr","uBoolToName","TRUE","FALSE","UNDEF","Exp","op","name","ConstExp","value","calc","expand","UNDEF_EXP","undefined","TRUE_EXP","FALSE_EXP","DEFAULT_EXP","LB","RB","SEPERATOR","UniExp","operatorValue","subExp","getSubExp","setSubExp","e","BinExp","operator","lhs","rhs","getLhsExp","getRhsExp","setLhsExp","setRhsExp","NOT_OP","NotExp","AND_OP","AndExp","OR_OP","OrExp","NAND_OP","NandExp","NOR_OP","NorExp","XOR_OP","XorExp"],"sources":["/home/mark/GIT/exp-tree/src/Exp.ts"],"sourcesContent":["// Abstraction of the concept of a boolean expression.\n// Deals with creation and calcution of such expressions, including constants values (T, F and U), \n// binary operations, unary operations (well NOT_OP only at the moment), and boolean logic extended to \n// undefined values.\n\n/*\n\tHere's the grammar the Exp inheritance tree conforms to (or enables) below... (BNF format-ish):\n\n\tExp ::= Exp | ConstExp | BinExp | NotExp\n\t// UniExp - no other unary operators except Not, so no point...\n\t\n\tNotExp ::= 'Not' Exp \n\n\tBinExp ::= binOp Exp Exp\n\tbinOp ::= 'And' | 'Or' | 'Xor' | 'Nand' | 'Nor'\n\n\tConstExp ::= trueExp | falseExp | undefExp\n\n\t// implented as immutable constants in code.\n\tundefExp ::= 'Undefined'\n\ttrueExp ::= 'True'\n\tfalseExp ::= 'False'\n\n\tKey:-\n\t'inQuotes' means the string in question can be found in the code.\n\tlowerCase first letter on a name means there is not a class for this in the impl - it's just for grammar expansion.\n\tUpperCase means there's a class for it in the impl.\n\n\tnb: no UI related stuff here.\n*/\n\nimport {  uBoolean, uNot, uAnd, uOr, uBoolToName } from './ubool';\n\n// backwards compatibility after file restructure.\nexport {  uNot, uAnd, uOr, TRUE, FALSE, UNDEF, uBoolToName } from './ubool';\n\n//******\nexport abstract class Exp\n{\n\tconstructor(private op: string) {};\t// save operator type\n\tname = () => this.op;\t\t\t\t// what is the name of the Exp's operator. Concrete impl, all Exp types.\n\tabstract expand(): \tstring;\t\t\t\t// return a string expansion of the Exp.\n\tabstract calc():\tuBoolean;\t\t\t// calculate the value of the Exp.\n}\n\n//******\nclass ConstExp extends Exp\t// nb: not exported. Only pre-defined constants are exported.\n{\n\tconstructor(private value: uBoolean) { super( uBoolToName(value) ); }\n\tcalc = () => this.value;\n\texpand = () => this.name();\n}\n\n/* standard constant expression values - exported */\nexport const UNDEF_EXP = \tnew ConstExp(undefined);\nexport const TRUE_EXP = \tnew ConstExp(true);\nexport const FALSE_EXP = \tnew ConstExp(false);\n\nexport const DEFAULT_EXP = UNDEF_EXP;\t// default parameter/argument value - not absolutely necessary.\n\nexport const LB = ' ( ';\nexport const RB = ' ) ';\nexport const SEPERATOR = ' , ';\n\nexport abstract class UniExp extends Exp\n{\n\tconstructor(private operatorValue: string, private subExp: Exp)\n\t{\n\t\tsuper(operatorValue);\n\t\tthis.setSubExp(subExp);\n\t}\n\n\t/*  Std Exp Ops */\n\texpand = () => this.name() + LB + this.getSubExp().expand() + RB;\n\t\n\t/* Unary Exp Specific Ops */\n\tgetSubExp = () => this.subExp\n\tsetSubExp = (e: Exp) => this.subExp = e;\n}\n\nexport abstract class BinExp extends Exp\n{\n\tconstructor(operator: string, private lhs: Exp, private rhs: Exp) \n\t{ \n\t\tsuper(operator); \n\t}\n\n\t/* Std Exp Ops - nb: No calc() as don't know how to calc() in abstract BinExp type  */\n\texpand = () => this.name() + LB + this.getLhsExp().expand() + SEPERATOR + this.getRhsExp().expand() + RB;\n\t\n\t/* BinExp only ops - i.e. only make sense for binary operators / expression nodes */\n\t// simple setters/getters - nb: these are implementations that all binary expressions will share.\n\t// here binary expression means any class derived from (extend-ing) BinExp\n\tsetLhsExp = (e: Exp) => this.lhs =  e;\n\tsetRhsExp = (e: Exp) => this.rhs =  e;\n\tgetLhsExp = () => this.lhs;\n\tgetRhsExp = () => this.rhs;\n}\n\nexport const NOT_OP = 'Not' as string;\nexport class NotExp extends UniExp\n{\n\tconstructor(subExp: Exp = DEFAULT_EXP) { super(NOT_OP, subExp); }\n\tcalc = (): uBoolean => uNot( this.getSubExp().calc() );\n}\n\nexport const AND_OP = 'And' as string;\nexport class AndExp extends BinExp\n{\n\tconstructor(lhs: Exp = DEFAULT_EXP, rhs: Exp = DEFAULT_EXP) { super (AND_OP, lhs, rhs); }\n\tcalc = () => uAnd( this.getLhsExp().calc(), this.getRhsExp().calc() )\n}\n\nexport const OR_OP = 'Or' as string\nexport class OrExp extends BinExp\n{\n\tconstructor(lhs: Exp = DEFAULT_EXP, rhs: Exp = DEFAULT_EXP) { super (OR_OP, lhs, rhs); }\n\tcalc = () => uOr(this.getLhsExp().calc(), this.getRhsExp().calc())\n}\n\nexport const NAND_OP = 'Nand' as string;\nexport class NandExp extends BinExp\n{\n\tconstructor(lhs: Exp = DEFAULT_EXP, rhs: Exp = DEFAULT_EXP) { super (NAND_OP, lhs, rhs); }\n\tcalc = () => uNot( uAnd(this.getLhsExp().calc(), this.getRhsExp().calc()) );\n}\n\nexport const NOR_OP = 'Nor' as string;\nexport class NorExp extends BinExp\n{\n\tconstructor(lhs: Exp = DEFAULT_EXP, rhs: Exp = DEFAULT_EXP) { super (NOR_OP, lhs, rhs); }\n\tcalc = () => uNot( uOr(this.getLhsExp().calc(), this.getRhsExp().calc()) )\n}\n\nexport const XOR_OP = 'Xor' as string;\nexport class XorExp extends BinExp \n{\n\tconstructor(lhs: Exp = DEFAULT_EXP, rhs: Exp = DEFAULT_EXP) { super (XOR_OP, lhs, rhs); }\n\tcalc = () => uOr(\n \t\tuAnd( this.getLhsExp().calc(), uNot(this.getRhsExp().calc()) ),\n\t\tuAnd( uNot(this.getLhsExp().calc()), this.getRhsExp().calc() )\n\t);\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}