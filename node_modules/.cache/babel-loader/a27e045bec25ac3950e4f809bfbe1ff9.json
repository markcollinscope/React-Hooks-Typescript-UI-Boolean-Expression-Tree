{"ast":null,"code":"// Abstraction of the concept of a boolean expression.\n// Deals with creation and calcution of such expressions, including constants values (T, F and U), \n// binary operations, unary operations (well NOT_OP only at the moment), and boolean logic extended to \n// undefined values.\n\n/*\n\tHere's the grammar the Exp inheritance tree conforms to (or enables) below... (BNF format-ish):\n\n\tExp ::= Exp | ConstExp | BinExp | NotExp\n\t// UniExp - no other unary operators except Not, so no point...\n\t\n\tNotExp ::= 'Not' Exp \n\n\tBinExp ::= binOp Exp Exp\n\tbinOp ::= 'And' | 'Or' | 'Xor' | 'Nand' | 'Nor'\n\n\tConstExp ::= trueExp | falseExp | undefExp\n\n\t// implented as immutable constants in code.\n\tundefExp ::= 'Undefined'\n\ttrueExp ::= 'True'\n\tfalseExp ::= 'False'\n\n\tKey:-\n\t'inQuotes' means the string in question can be found in the code.\n\tlowerCase first letter on a name means there is not a class for this in the impl - it's just for grammar expansion.\n\tUpperCase means there's a class for it in the impl.\n\n\tnb: no UI related stuff here.\n*/\nimport { uNot, uAnd, uOr, uBoolToName } from './ubool'; // backwards compatibility after file restructure.\n\nexport { uNot, uAnd, uOr, TRUE, FALSE, UNDEF, uBoolToName } from './ubool'; //******\n\nexport class Exp {\n  constructor(op) {\n    this.op = op;\n\n    this.name = () => this.op;\n  } // calculate the value of the Exp.\n\n\n} //******\n\nclass ConstExp extends Exp // nb: not exported. Only pre-defined constants are exported.\n{\n  constructor(value) {\n    super(uBoolToName(value));\n    this.value = value;\n\n    this.calc = () => this.value;\n\n    this.expand = () => this.name();\n  }\n\n}\n/* standard constant expression values - exported */\n\n\nexport const UNDEF_EXP = new ConstExp(undefined);\nexport const TRUE_EXP = new ConstExp(true);\nexport const FALSE_EXP = new ConstExp(false);\nexport const DEFAULT_EXP = UNDEF_EXP; // default parameter/argument value - not absolutely necessary.\n\nexport const LB = ' ( ';\nexport const RB = ' ) ';\nexport const SEPERATOR = ' , ';\nexport class UniExp extends Exp {\n  constructor(operatorValue, subExp) {\n    super(operatorValue);\n    this.operatorValue = operatorValue;\n    this.subExp = subExp;\n\n    this.expand = () => this.name() + LB + this.getSubExp().expand() + RB;\n\n    this.getSubExp = () => this.subExp;\n\n    this.setSubExp = e => this.subExp = e;\n\n    this.setSubExp(subExp);\n  }\n  /*  Std Exp Ops */\n\n\n}\nexport class BinExp extends Exp {\n  constructor(operator, lhs, rhs) {\n    super(operator);\n    this.lhs = lhs;\n    this.rhs = rhs;\n\n    this.expand = () => this.name() + LB + this.getLhsExp().expand() + SEPERATOR + this.getRhsExp().expand() + RB;\n\n    this.setLhsExp = e => this.lhs = e;\n\n    this.setRhsExp = e => this.rhs = e;\n\n    this.getLhsExp = () => this.lhs;\n\n    this.getRhsExp = () => this.rhs;\n  }\n  /* Std Exp Ops - nb: No calc() as don't know how to calc() in abstract BinExp type  */\n\n\n}\nexport const NOT_OP = 'Not';\nexport class NotExp extends UniExp {\n  constructor() {\n    let subExp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_EXP;\n    super(NOT_OP, subExp);\n\n    this.calc = () => uNot(this.getSubExp().calc());\n  }\n\n}\nexport const AND_OP = 'And';\nexport class AndExp extends BinExp {\n  constructor() {\n    let lhs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_EXP;\n    let rhs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_EXP;\n    super(AND_OP, lhs, rhs);\n\n    this.calc = () => uAnd(this.getLhsExp().calc(), this.getRhsExp().calc());\n  }\n\n}\nexport const OR_OP = 'Or';\nexport class OrExp extends BinExp {\n  constructor() {\n    let lhs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_EXP;\n    let rhs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_EXP;\n    super(OR_OP, lhs, rhs);\n\n    this.calc = () => uOr(this.getLhsExp().calc(), this.getRhsExp().calc());\n  }\n\n}\nexport const NAND_OP = 'Nand';\nexport class NandExp extends BinExp {\n  constructor() {\n    let lhs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_EXP;\n    let rhs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_EXP;\n    super(NAND_OP, lhs, rhs);\n\n    this.calc = () => uNot(uAnd(this.getLhsExp().calc(), this.getRhsExp().calc()));\n  }\n\n}\nexport const NOR_OP = 'Nor';\nexport class NorExp extends BinExp {\n  constructor() {\n    let lhs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_EXP;\n    let rhs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_EXP;\n    super(NOR_OP, lhs, rhs);\n\n    this.calc = () => uNot(uOr(this.getLhsExp().calc(), this.getRhsExp().calc()));\n  }\n\n}\nexport const XOR_OP = 'Xor';\nexport class XorExp extends BinExp {\n  constructor() {\n    let lhs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_EXP;\n    let rhs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_EXP;\n    super(XOR_OP, lhs, rhs);\n\n    this.calc = () => uOr(uAnd(this.getLhsExp().calc(), uNot(this.getRhsExp().calc())), uAnd(uNot(this.getLhsExp().calc()), this.getRhsExp().calc()));\n  }\n\n}","map":{"version":3,"sources":["/home/mark/GIT/exp-tree/src/Exp.ts"],"names":["uNot","uAnd","uOr","uBoolToName","TRUE","FALSE","UNDEF","Exp","constructor","op","name","ConstExp","value","calc","expand","UNDEF_EXP","undefined","TRUE_EXP","FALSE_EXP","DEFAULT_EXP","LB","RB","SEPERATOR","UniExp","operatorValue","subExp","getSubExp","setSubExp","e","BinExp","operator","lhs","rhs","getLhsExp","getRhsExp","setLhsExp","setRhsExp","NOT_OP","NotExp","AND_OP","AndExp","OR_OP","OrExp","NAND_OP","NandExp","NOR_OP","NorExp","XOR_OP","XorExp"],"mappings":"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","sourcesContent":["// Abstraction of the concept of a boolean expression.\n// Deals with creation and calcution of such expressions, including constants values (T, F and U), \n// binary operations, unary operations (well NOT_OP only at the moment), and boolean logic extended to \n// undefined values.\n\n/*\n\tHere's the grammar the Exp inheritance tree conforms to (or enables) below... (BNF format-ish):\n\n\tExp ::= Exp | ConstExp | BinExp | NotExp\n\t// UniExp - no other unary operators except Not, so no point...\n\t\n\tNotExp ::= 'Not' Exp \n\n\tBinExp ::= binOp Exp Exp\n\tbinOp ::= 'And' | 'Or' | 'Xor' | 'Nand' | 'Nor'\n\n\tConstExp ::= trueExp | falseExp | undefExp\n\n\t// implented as immutable constants in code.\n\tundefExp ::= 'Undefined'\n\ttrueExp ::= 'True'\n\tfalseExp ::= 'False'\n\n\tKey:-\n\t'inQuotes' means the string in question can be found in the code.\n\tlowerCase first letter on a name means there is not a class for this in the impl - it's just for grammar expansion.\n\tUpperCase means there's a class for it in the impl.\n\n\tnb: no UI related stuff here.\n*/\n\nimport {  uBoolean, uNot, uAnd, uOr, uBoolToName } from './ubool';\n\n// backwards compatibility after file restructure.\nexport {  uNot, uAnd, uOr, TRUE, FALSE, UNDEF, uBoolToName } from './ubool';\n\n//******\nexport abstract class Exp\n{\n\tconstructor(private op: string) {};\t// save operator type\n\tname = () => this.op;\t\t\t\t// what is the name of the Exp's operator. Concrete impl, all Exp types.\n\tabstract expand(): \tstring;\t\t\t\t// return a string expansion of the Exp.\n\tabstract calc():\tuBoolean;\t\t\t// calculate the value of the Exp.\n}\n\n//******\nclass ConstExp extends Exp\t// nb: not exported. Only pre-defined constants are exported.\n{\n\tconstructor(private value: uBoolean) { super( uBoolToName(value) ); }\n\tcalc = () => this.value;\n\texpand = () => this.name();\n}\n\n/* standard constant expression values - exported */\nexport const UNDEF_EXP = \tnew ConstExp(undefined);\nexport const TRUE_EXP = \tnew ConstExp(true);\nexport const FALSE_EXP = \tnew ConstExp(false);\n\nexport const DEFAULT_EXP = UNDEF_EXP;\t// default parameter/argument value - not absolutely necessary.\n\nexport const LB = ' ( ';\nexport const RB = ' ) ';\nexport const SEPERATOR = ' , ';\n\nexport abstract class UniExp extends Exp\n{\n\tconstructor(private operatorValue: string, private subExp: Exp)\n\t{\n\t\tsuper(operatorValue);\n\t\tthis.setSubExp(subExp);\n\t}\n\n\t/*  Std Exp Ops */\n\texpand = () => this.name() + LB + this.getSubExp().expand() + RB;\n\t\n\t/* Unary Exp Specific Ops */\n\tgetSubExp = () => this.subExp\n\tsetSubExp = (e: Exp) => this.subExp = e;\n}\n\nexport abstract class BinExp extends Exp\n{\n\tconstructor(operator: string, private lhs: Exp, private rhs: Exp) \n\t{ \n\t\tsuper(operator); \n\t}\n\n\t/* Std Exp Ops - nb: No calc() as don't know how to calc() in abstract BinExp type  */\n\texpand = () => this.name() + LB + this.getLhsExp().expand() + SEPERATOR + this.getRhsExp().expand() + RB;\n\t\n\t/* BinExp only ops - i.e. only make sense for binary operators / expression nodes */\n\t// simple setters/getters - nb: these are implementations that all binary expressions will share.\n\t// here binary expression means any class derived from (extend-ing) BinExp\n\tsetLhsExp = (e: Exp) => this.lhs =  e;\n\tsetRhsExp = (e: Exp) => this.rhs =  e;\n\tgetLhsExp = () => this.lhs;\n\tgetRhsExp = () => this.rhs;\n}\n\nexport const NOT_OP = 'Not' as string;\nexport class NotExp extends UniExp\n{\n\tconstructor(subExp: Exp = DEFAULT_EXP) { super(NOT_OP, subExp); }\n\tcalc = (): uBoolean => uNot( this.getSubExp().calc() );\n}\n\nexport const AND_OP = 'And' as string;\nexport class AndExp extends BinExp\n{\n\tconstructor(lhs: Exp = DEFAULT_EXP, rhs: Exp = DEFAULT_EXP) { super (AND_OP, lhs, rhs); }\n\tcalc = () => uAnd( this.getLhsExp().calc(), this.getRhsExp().calc() )\n}\n\nexport const OR_OP = 'Or' as string\nexport class OrExp extends BinExp\n{\n\tconstructor(lhs: Exp = DEFAULT_EXP, rhs: Exp = DEFAULT_EXP) { super (OR_OP, lhs, rhs); }\n\tcalc = () => uOr(this.getLhsExp().calc(), this.getRhsExp().calc())\n}\n\nexport const NAND_OP = 'Nand' as string;\nexport class NandExp extends BinExp\n{\n\tconstructor(lhs: Exp = DEFAULT_EXP, rhs: Exp = DEFAULT_EXP) { super (NAND_OP, lhs, rhs); }\n\tcalc = () => uNot( uAnd(this.getLhsExp().calc(), this.getRhsExp().calc()) );\n}\n\nexport const NOR_OP = 'Nor' as string;\nexport class NorExp extends BinExp\n{\n\tconstructor(lhs: Exp = DEFAULT_EXP, rhs: Exp = DEFAULT_EXP) { super (NOR_OP, lhs, rhs); }\n\tcalc = () => uNot( uOr(this.getLhsExp().calc(), this.getRhsExp().calc()) )\n}\n\nexport const XOR_OP = 'Xor' as string;\nexport class XorExp extends BinExp \n{\n\tconstructor(lhs: Exp = DEFAULT_EXP, rhs: Exp = DEFAULT_EXP) { super (XOR_OP, lhs, rhs); }\n\tcalc = () => uOr(\n \t\tuAnd( this.getLhsExp().calc(), uNot(this.getRhsExp().calc()) ),\n\t\tuAnd( uNot(this.getLhsExp().calc()), this.getRhsExp().calc() )\n\t);\n}"]},"metadata":{},"sourceType":"module"}