{"ast":null,"code":"// Abstraction of the concept of a boolean expression.\n// Deals with creation and calcution of such expressions, including constants values (T, F and U), \n// binary operations, unary operations (well NOT_OP only at the moment), and boolean logic extended to \n// undefined values.\n\n/*\n\tHere's the grammar the Exp inheritance tree conforms to (or enables) below... (BNF format-ish):\n\n\tExp ::= Exp | ConstExp | BinExp | NotExp\n\t// UniExp - no other unary operators except Not, so no point...\n\t\n\tNotExp ::= 'Not' Exp \n\n\tBinExp ::= binOp Exp Exp\n\tbinOp ::= 'And' | 'Or' | 'Xor' | 'Nand' | 'Nor'\n\n\tConstExp ::= trueExp | falseExp | undefExp\n\n\t// implented as immutable constants in code.\n\tundefExp ::= 'Undefined'\n\ttrueExp ::= 'True'\n\tfalseExp ::= 'False'\n\n\tKey:-\n\t'inQuotes' means the string in question can be found in the code.\n\tlowerCase first letter on a name means there is not a class for this in the impl - it's just for grammar expansion.\n\tUpperCase means there's a class for it in the impl.\n\n\tnb: no UI related stuff here.\n*/\n//******\nconst uNot = v => v === undefined ? undefined : !v;\n\nconst uAnd = (l, r) => containsUndefined(l, r) ? undefined : l && r;\n\nconst uOr = (l, r) => containsUndefined(l, r) ? undefined : l || r; //******\n// abstract base class - which Typescript doesn't support directly, so progError()...\n\n\nexport class Exp {} //******\n\nclass ConstExp extends Exp {\n  static nameString(v) {\n    if (v === true) return 'True';\n    if (v === false) return 'False';\n    return 'Undefined';\n  }\n\n  constructor(value) {\n    super();\n    this.value = value;\n\n    this.calc = () => this.value;\n\n    this.name = () => ConstExp.nameString(this.value);\n\n    this.expand = () => this.name();\n  }\n\n}\n\nexport const UNDEF_EXP = new ConstExp(undefined);\nexport const TRUE_EXP = new ConstExp(true);\nexport const FALSE_EXP = new ConstExp(false);\nexport const UNDEF = UNDEF_EXP.name();\nexport const TRUE = TRUE_EXP.name();\nexport const FALSE = FALSE_EXP.name();\n\nconst containsUndefined = (l, r) => l === undefined || r === undefined; //******\n\n\nexport class NotExp extends Exp {\n  constructor() {\n    let subExp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : UNDEF_EXP;\n    super();\n    this.subExp = subExp;\n\n    this.getSubExp = () => this.subExp;\n\n    this.setSubExp = e => this.subExp = e;\n\n    this.name = () => 'Not';\n\n    this.calc = () => uNot(this.getSubExp().calc());\n\n    this.expand = () => this.name() + LB + this.getSubExp().expand() + RB;\n\n    this.setSubExp(subExp);\n  }\n\n}\nexport const NOT_OP = new NotExp().name(); //******\n// exported for tests (only). for formatting expressions.\n\nexport const LB = ' ( ';\nexport const RB = ' ) ';\nexport const SEPERATOR = ' , ';\nexport class BinExp extends Exp {\n  constructor() {\n    let lhs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : UNDEF_EXP;\n    let rhs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : UNDEF_EXP;\n    super();\n    this.lhs = lhs;\n    this.rhs = rhs;\n\n    this.setLhsExp = e => this.lhs = e;\n\n    this.setRhsExp = e => this.rhs = e;\n\n    this.getLhsExp = () => this.lhs;\n\n    this.getRhsExp = () => this.rhs;\n\n    this.expand = () => this.name() + LB + this.getLhsExp().expand() + SEPERATOR + this.getRhsExp().expand() + RB;\n  }\n\n}\nexport class AndExp extends BinExp {\n  constructor() {\n    super(...arguments);\n\n    this.name = () => 'And';\n\n    this.calc = () => uAnd(this.getLhsExp().calc(), this.getRhsExp().calc());\n  }\n\n}\nexport const AND_OP = new AndExp().name();\nexport class OrExp extends BinExp {\n  constructor() {\n    super(...arguments);\n\n    this.name = () => 'Or';\n\n    this.calc = () => uOr(this.getLhsExp().calc(), this.getRhsExp().calc());\n  }\n\n}\nexport const OR_OP = new OrExp().name();\nexport class NandExp extends BinExp {\n  constructor() {\n    super(...arguments);\n\n    this.name = () => 'Nand';\n\n    this.calc = () => uNot(uAnd(this.getLhsExp().calc(), this.getRhsExp().calc()));\n  }\n\n}\nexport const NAND_OP = new NandExp().name();\nexport class NorExp extends BinExp {\n  constructor() {\n    super(...arguments);\n\n    this.name = () => 'Nor';\n\n    this.calc = () => uNot(uOr(this.getLhsExp().calc(), this.getRhsExp().calc()));\n  }\n\n}\nexport const NOR_OP = new NorExp().name();\nexport class XorExp extends BinExp {\n  constructor() {\n    super(...arguments);\n\n    this.name = () => 'Xor';\n\n    this.calc = () => uOr(uAnd(this.getLhsExp().calc(), uNot(this.getRhsExp().calc())), uAnd(uNot(this.getLhsExp().calc()), this.getRhsExp().calc()));\n  }\n\n}\nexport const XOR_OP = new XorExp().name();\nexport const uBoolToName = v => v === undefined ? UNDEF : v ? TRUE : FALSE;","map":{"version":3,"sources":["/home/mark/GIT/exp-tree/src/Exp.ts"],"names":["uNot","v","undefined","uAnd","l","r","containsUndefined","uOr","Exp","ConstExp","nameString","constructor","value","calc","name","expand","UNDEF_EXP","TRUE_EXP","FALSE_EXP","UNDEF","TRUE","FALSE","NotExp","subExp","getSubExp","setSubExp","e","LB","RB","NOT_OP","SEPERATOR","BinExp","lhs","rhs","setLhsExp","setRhsExp","getLhsExp","getRhsExp","AndExp","AND_OP","OrExp","OR_OP","NandExp","NAND_OP","NorExp","NOR_OP","XorExp","XOR_OP","uBoolToName"],"mappings":"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","sourcesContent":["// Abstraction of the concept of a boolean expression.\n// Deals with creation and calcution of such expressions, including constants values (T, F and U), \n// binary operations, unary operations (well NOT_OP only at the moment), and boolean logic extended to \n// undefined values.\n\n/*\n\tHere's the grammar the Exp inheritance tree conforms to (or enables) below... (BNF format-ish):\n\n\tExp ::= Exp | ConstExp | BinExp | NotExp\n\t// UniExp - no other unary operators except Not, so no point...\n\t\n\tNotExp ::= 'Not' Exp \n\n\tBinExp ::= binOp Exp Exp\n\tbinOp ::= 'And' | 'Or' | 'Xor' | 'Nand' | 'Nor'\n\n\tConstExp ::= trueExp | falseExp | undefExp\n\n\t// implented as immutable constants in code.\n\tundefExp ::= 'Undefined'\n\ttrueExp ::= 'True'\n\tfalseExp ::= 'False'\n\n\tKey:-\n\t'inQuotes' means the string in question can be found in the code.\n\tlowerCase first letter on a name means there is not a class for this in the impl - it's just for grammar expansion.\n\tUpperCase means there's a class for it in the impl.\n\n\tnb: no UI related stuff here.\n*/\n\n//******\ntype uBoolean = true | false | undefined;\n\nconst uNot = (v: uBoolean) => (v === undefined) ? undefined : !v;\nconst uAnd = (l: uBoolean, r: uBoolean) => containsUndefined(l, r) ? undefined : l && r;\nconst uOr = (l: uBoolean, r: uBoolean) => containsUndefined(l, r) ? undefined : l || r;\n\n//******\n// abstract base class - which Typescript doesn't support directly, so progError()...\nexport abstract class Exp  \n{\n\tabstract name() : \tstring;\n\tabstract expand(): \tstring;\n\tabstract calc():\tuBoolean;\n}\n\n//******\nclass ConstExp extends Exp\n{\n\tstatic nameString(v: uBoolean): string\n\t{\n\t\tif (v === true) return 'True';\n\t\tif (v === false) return 'False';\n\t\treturn 'Undefined';\n\t}\n\n\tconstructor(private value: uBoolean) { super(); }\n\tcalc = () => this.value;\n\tname = () => ConstExp.nameString(this.value);\n\texpand = () => this.name();\n}\n\nexport const UNDEF_EXP = \tnew ConstExp(undefined);\nexport const TRUE_EXP = \tnew ConstExp(true);\nexport const FALSE_EXP = \tnew ConstExp(false);\n\nexport const UNDEF = UNDEF_EXP.name();\nexport const TRUE = TRUE_EXP.name();\nexport const FALSE = FALSE_EXP.name();\n\nconst containsUndefined = (l: uBoolean, r: uBoolean) => (l === undefined) || (r === undefined);\n\n//******\nexport class NotExp extends Exp\n{\n\tconstructor(private subExp: Exp = UNDEF_EXP)\n\t{\n\t\tsuper()\n\t\tthis.setSubExp(subExp)\n\t}\n\n\tgetSubExp = () => this.subExp\n\tsetSubExp = (e: Exp) => this.subExp = e;\n\n\tname = () => 'Not';\n\tcalc = (): uBoolean => uNot( this.getSubExp().calc() );\n\texpand = () => this.name() + LB + this.getSubExp().expand() + RB;\n}\nexport const NOT_OP = (new NotExp()).name();\n\n//******\n// exported for tests (only). for formatting expressions.\nexport const LB = ' ( ';\nexport const RB = ' ) ';\nexport const SEPERATOR = ' , ';\n\nexport abstract class BinExp extends Exp\n{\n\tconstructor(private lhs: Exp = UNDEF_EXP, private rhs: Exp = UNDEF_EXP) { super(); }\n\tsetLhsExp = (e: Exp) => this.lhs =  e;\n\tsetRhsExp = (e: Exp) => this.rhs =  e;\n\tgetLhsExp = () => this.lhs\n\tgetRhsExp = () => this.rhs\n\texpand = () => this.name() + LB + this.getLhsExp().expand() + SEPERATOR + this.getRhsExp().expand() + RB;\n}\n\nexport class AndExp extends BinExp\n{\n\tname = () => 'And';\n\tcalc = () => uAnd( this.getLhsExp().calc(), this.getRhsExp().calc() )\n}\nexport const AND_OP = (new AndExp()).name();\n\nexport class OrExp extends BinExp\n{\n\tname = () => 'Or';\n\tcalc = () => uOr(this.getLhsExp().calc(), this.getRhsExp().calc())\n}\nexport const OR_OP = (new OrExp()).name();\n\nexport class NandExp extends BinExp\n{\n\tname = () => 'Nand';\n\tcalc = () => uNot( uAnd(this.getLhsExp().calc(), this.getRhsExp().calc()) );\n}\nexport const NAND_OP = (new NandExp()).name();\n\nexport class NorExp extends BinExp {\n\tname = () => 'Nor';\n\tcalc = () => uNot( uOr(this.getLhsExp().calc(), this.getRhsExp().calc()) )\n}\nexport const NOR_OP = (new NorExp()).name();\n\nexport class XorExp extends BinExp \n{\n\tname = () => 'Xor';\n\tcalc = () => uOr(\n\t\tuAnd( this.getLhsExp().calc(), uNot(this.getRhsExp().calc()) ),\n\t\tuAnd( uNot(this.getLhsExp().calc()), this.getRhsExp().calc() )\n\t);\n}\nexport const XOR_OP = (new XorExp()).name();\n\nexport const uBoolToName = (v: uBoolean) => v === undefined ? UNDEF : (v ? TRUE : FALSE);"]},"metadata":{},"sourceType":"module"}